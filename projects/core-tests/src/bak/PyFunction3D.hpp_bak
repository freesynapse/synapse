
#pragma once

#include "Meshgrid.hpp"

#define DEBUG_PY_FUNCTION_CALLS


namespace Syn
{
    //-----------------------------------------------------------------------------------
    /*
     * Implementation of a surface, using a user-supplied python script to calculate the
     * z values. The member Ref<MeshShape> is then used for rendering.
     * Function3D is not responsible for initializing the python interpreter, this has to
     * be handled by Synapse (Syn::SynPy::).
     */
    class PyFunction3D : public Meshgrid
    {
    private:
        Ref<MeshShape> m_mesh = nullptr;
        std::string m_module = "";
        std::string m_function = "";

    public:
        /* (using only parent ctors/dtors) */
        PyFunction3D(const Linspace& _x, const Linspace& _y) :
            Meshgrid(_x, _y)
        {}

        virtual void updateAxes(const Linspace& _x, const Linspace& _y) 
        { m_x = _x; m_y = _y;}
        virtual void updateXAxis(const Linspace& _x)
        { m_x = _x;}
        virtual void updateYAxis(const Linspace& _y)
        { m_y = _y;}


        /*
         * User-supplied python module (script file) and function name. The function have to take
         * two Linspaces, comparable to NumPys linspaces. Expects a returned nd.array of 
         * shape[0] == (m_x.steps * m_y.steps). The order of the result is expected to be x first, 
         * i.e. for every m_y.steps there are m_x.steps.
         */
        void computeFunctionFromPySrc(const std::string& _module, const std::string& _func);

    private:
        virtual void updateCoordinates() override;

    };

}