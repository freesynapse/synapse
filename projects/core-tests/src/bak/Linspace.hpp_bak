
#pragma once

#include <iostream>


namespace Syn
{
    template<typename T>
    class limit_2D_t
    {
    public:
        T min = 0.0f;
        T max = 0.0f;

        limit_2D_t() = default;
        limit_2D_t(const limit_2D_t&) = default;
        limit_2D_t(T _min, T _max)
        {
            min = MIN(_min, _max);
            max = MAX(_min, _max);
        }
        T range() { return max - min; }
        void print(bool _newline=true) 
        { 
            std::cout<<"min="<<min<<", max="<<max;
            if (_newline) std::cout << '\n';
        }
    };

    //-----------------------------------------------------------------------------------
    class Linspace
    {
    public:
        long double* values = nullptr;
        limit_2D_t<long double> lim = { 0.0, 1.0 };
        uint32_t steps = 2;

    public:
        // naive constructor
        Linspace() = default;
        // specific constructor
        Linspace(long double _lim_min, long double _lim_max, uint32_t _steps) :
            lim(_lim_min, _lim_max), steps(_steps)
        { updateLinspace(); }
        // copy constructor
        Linspace(const Linspace& _other) :
            lim(_other.lim), 
            steps(_other.steps), 
            values(new long double[_other.steps])
        {
            // deep copy of data
            std::copy(_other.values, _other.values + _other.steps, values);
        }
        // copy assignment operator
        Linspace& operator=(const Linspace& _other)
        {
            if (this != &_other)
            {
                // free exisiting data
                delete[] values;
                lim = _other.lim;
                steps = _other.steps;
                values = new long double[steps];
                // deep copy of data
                std::copy(_other.values, _other.values + _other.steps, values);
            }
            return *this;
        }
        ~Linspace() 
        { if (values != nullptr) delete[] values; values = nullptr; }

        uint32_t size() const { return steps; }
        long double operator[](uint32_t _index) { return values[_index]; }
        long double get(uint32_t _index) { return values[_index]; }
        long double* getValues() { return values; }
        void print() const { printf("Linspace [ %.2Lf  %.2Lf ], n=%d\n", lim.min, lim.max, steps); }

    public:
        void setLinspace(long double _lim_min, long double _lim_max, uint32_t _steps)
        { lim = limit_2D_t<long double>(_lim_min, _lim_max); steps = _steps; updateLinspace(); }
        void setLinspace(long double _lim_min, long double _lim_max)
        { lim = limit_2D_t<long double>(_lim_min, _lim_max); updateLinspace(); }
        void setLinspace(uint32_t _steps)
        { steps = _steps; updateLinspace(); }

    private:
        void updateLinspace()
        {
            if (values != nullptr) delete[] values;

            values = new long double[steps];
            
            long double step = lim.range() / (long double)(steps - 1);
            long double f = lim.min;
            for (int i = 0; i < steps; i++)
            {
                values[i] = f;
                f += step;
            }
        }
    };


}